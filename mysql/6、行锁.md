## 行锁

​		MySQL的行锁是引擎层由各个引擎自己实现的。但并不是所有的引擎都支持行锁，比如MyISAM引擎就不支持行锁。不支持行锁以为着并发控制只能使用表锁，对于这种引擎的表，同一张表上任何时刻只能有一个更新在执行，这就会影响到业务并发度。InnoDB是支持行锁的，这也是MyISAM呗InnoDB替代的重要原因之一。

### 两阶段锁协议

​		在InnoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放锁资源，需要等到事务结束时才释放。这就是两阶段锁协议。

​		如果事务中需要锁多个行，要把最可能造成锁冲突，最可能影响并发度的锁尽量往后放。

### 死锁和死锁检测

​		当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，被称为死锁。

针对死锁检测，有两种策略：

- 1、直接进入等待，知道超时。这个超时时间可以通过参数innod_lock_wait_timeout来设置
- 2、发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以



​		在InnoDB中，innodb_lock_wait_timeout的默认值是50s，意味着如果采用第一个策略，当出现死锁以后，第一个呗锁住的线程需要过50S也会超时退出，然后其他线程才有可能继续执行。对于在线服务来说，这个等待时间往往是无法接受的。

​		但是，我们又不能直接把这个时间设置成一个很小的值，当出现死锁的时候，确实很快就可以解开，但如果不是死锁，而是正常的锁等待，这样就会出现误伤的情况。