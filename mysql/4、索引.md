## 索引

### 索引的常见模型

- 哈希表

  > ​		哈希表是一种以键—值(key—value)存储数据的结构,我们只需要输入寻找的key，就可以找到对应的value。哈希的思路很简单，用哈希算法计算出key值，确定key存储数组的位置，然后将value放入这个位置。
  >
  > ​		不可避免再哈希计算时会出现重复的key值，这也就是所谓的"哈希冲突"，处理方式就是将value的的数据结构替换成链表。
  >
  > ​		但是哈希表的缺点也很明显，在进行区间查询时，只能进行全表查询。
  >
  > ​		所以哈希表这种结构适用于只有等值查询的场景，如NoSQL等。

- 有序数组

  >​		而有序数组就不同了，在等值查询和范围查询场景中的性能就都非常优秀。如果只是看查询效率的话，有序数组就是最好的数据结构。
  >
  >​		相反有序数组的缺点就是需要更新数据时候的麻烦，如果插入的数据位于数组中间，那么就必须挪动后面所有的数据，成本太高。
  >
  >​		所以，有序数组适用于静态存储引擎。

- 二叉树

  > 二叉树的特点就是：父节点的所有左子节点都比父节点小，而右子节点所有节点的值大于父节点的值。
  >
  > 所以按照二叉树的遍历查询，所能得到查询时间复杂度为O(log(N))，那么这时需要保持查询的时间复杂度为O(log(N))时，二叉树也就需要做平衡(拥有自平衡的二叉树叫AVL树)。
  >
  > 但是我们大多数数据库不会选择采用二叉树也选择采用多叉树就是因为由于二叉树的特点只有两个子节点，当我们数据量过多是，树的层数会过高从而导致查询效率过低。

​		在 MySQL 中，索引是在存储引擎层实现的，所以并没有统一的索引标准，即不同存储引擎的索引的工作方式并不一样。而即使多个存储引擎支持同一种类型的索引，其底层的实现也可能不同。

---



### InnoDB的索引模型

​		在innoDB中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。有因为InnoDB使用了B+数做索引模型，所以数据都存储在B+树种。

**每一个索引都会在InnoDB里对应一课B+树**

​		在mysql中默认建表所使用的搜索引擎就为Innodb搜索引擎，当然也可以显示的在建表语句中表示。

```mysql
mysql> create table T(
id int not null primary key, 
k int not null, 
name varchar(16),
index (k))engine=InnoDB;
```



**主键索引的叶子节点存的是整行数据。在InnoDB中，主键索引也被称为聚簇索引(clustered index)**

**非主键索引的叶子节点内容是主键的值以及对应列的值。在InnoDB里，非主键索引也被称为二级索引**



**主键索引与普通索引的查询的区别**

- 如果语句是 select * from T where ID=500，即主键查询方式，则只需要搜索 ID 这棵 B+ 树。
- 如果语句是 select * from T where k=5，即普通索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为回表。

​		基于非主键索引，如果返回列不存在索引中，需要多一步回表操作。因此，我们在查询时尽量使用主键查询或者满足普通索引中的列。

---



### 索引维护

​		B+树为了维护索引有序性，在插入新值的时候需要做必要的维护。如果在插入新值时当前节点数据页内存已经满了，根据B+数的算法，这时候需要申请一个新的数据页，然后挪动部分数据过去，这个过程也叫节点分裂。这中情况下，性能会受到影响。

**除了性能外，页分裂操作还会影响数据页的使用率。**

​		有分裂就会有合并，当相邻两个页由于删除了数据，利用率很低之后，会将数据页合并。合并的过程，可以认为是分页过程的逆过程。

基于上诉所说，可以参考一个引擎维护案例

> 你可能在一些建表规范里面见到过类似的描述，要求建表语句里一定要有自增主键。当然事无绝对，我们来分析一下哪些场景下应该使用自增主键，而哪些场景下不应该。

​		自增主键是指自增列上定义的主键，在建表语句中一般是这么定义的： NOT NULL PRIMARY KEY AUTO_INCREMENT。

​		插入新记录的时候可以不指定 ID 的值，系统会获取当前 ID 最大值加 1 作为下一条记录的 ID 值。

​		也就是说，自增主键的插入数据模式，正符合了我们前面提到的递增插入的场景。每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。

### 覆盖索引

​		在基于查询时，由于返回列已经包含在我们所需返回内容中，而无需更具主键在进行回表主键索引查询数据，这个过程我们也称为索引覆盖。

​		由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一种常用的性能优化手段。

当然，索引字段的维护总是有代价的。因此，在建立冗余索引来支持覆盖索引时就需要权衡考虑了。

---



### 最左前缀原则

​		B+ 树这种索引结构，可以利用索引的“最左前缀”，来定位记录。

​		基于对最左前缀索引的说明，在建立联合索引的时候，需要着重考虑安排索引内的字段顺序。

​		如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。

---



### 索引下推

​		索引下推MySQL5.6以后引入的新特性，在之前说过的回表操作时，索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。

下面以sql与图文举例



```mysql

CREATE TABLE `tuser` (
  `id` int(11) NOT NULL,
  `id_card` varchar(32) DEFAULT NULL,
  `name` varchar(32) DEFAULT NULL,
  `age` int(11) DEFAULT NULL,
  `ismale` tinyint(1) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `id_card` (`id_card`),
  KEY `name_age` (`name`,`age`)
) ENGINE=InnoDB
```



```mysql
select * from tuser where name like '张%' and age=10 and ismale=1;
```

​		当我们在使用该查询语句时，MySQL5.6之前版本执行流程为先查询出name为张XX的数据，然后根据主键id

​		回表查询age的值在进行判断，而在5.6之后引入索引下推，会在同时判断索引中满足条件的列，在将满足条件列中的主键id回表查询数据并进行返回。

![无索引下推执行流程](https://gitee.com/zuoyii/picture/raw/master/img/2E9B4EA5-AB37-49B2-B6C3-D2AA8B840279.png)

![索引下推执行流程](https://gitee.com/zuoyii/picture/raw/master/img/2EA7FF46-0082-4211-A03D-E68E47E4D846.png)