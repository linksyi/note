## 事务到底是隔离还是不隔离的

在MySQL里，有两个视图的概念：

- 一个是view。他是一个用查询语句定义的虚拟表，在调用的时候执行查询语句并生成结果。创建视图的句法是create view ...，而他的查询方法与表一样。
- 另一个是InnoDB在实现MVCC时用到的一致性读视图，及consistent read view，用于支持RC(read commit，读提交)和RR(Repeatable read，可重复读)隔离级别的实现。

### "快照"在MVCC里是怎么工作的

​		在可重复读隔离离别下，事务在启动的时候就"拍了个快照"。

​		在InnoDB里面每个事务有一个唯一的事务ID，叫做transaction id。它是在失误开始的时候向InnoDB的失误系统申请的，是按申请顺序严格递增的。

​		而在数据库中，每行数据也是有多个版本的。每次事务更新数据的时候，都会生成一个新的数据版本，并把trancaction id 赋值给这个数据版本的失误ID。记为**row trx_id**。同事，旧的数据版本要保留，并且在新的数据版本中，能够有信息可以直接拿到它

​		在实现上，InnoDB为每个事务构造了一个数组，用来保存这个事务启动书剑，单签正在活跃的所有事务ID。活跃是指启动了但还没提交的事务。

​		数组里面事务ID最小值记为低水位，当前系统里面已经创建过的ID最大值+1记为高水位

​		视图数组和高低水位，就组成了当前事务的一致性视图(read-view)

![D1A23E8F-9AF3-4533-B4E5-16F8464C2F80](https://gitee.com/zuoyii/picture/raw/master/img/D1A23E8F-9AF3-4533-B4E5-16F8464C2F80.png)

这样，对于当前事务启动瞬间来说，一个数据版本的row trx_id，有一下几种可能：

1. 如果落在绿色部分，表示这个版本是已提交事务或者是当前事务自己生成的，这个数据是可见的；

2. 如果落在红色部分，表示这个版本是由将来启动的事务生成的，是不可见的；

3. 如果罗在黄色部分则会出线两种情况：

   3.1	若row trx_id在数组中，则表示事务未提交，则不可见；

   3.2	若row trx_id不在数组中，则表示事务已提交，可见；

### 当前读

​		更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”（current read）。	

​		如果两个线程，A线程开始了但是当为执行update语句，B线程直接执行了update语句，这时A线程在开是执行update语句，最终的值获取到的为B线程已经修改后的值，这就是当前读，当前读就是防止在更新操作时，由于cpu资源的增抢，反之事务提交被其他事务覆盖。

