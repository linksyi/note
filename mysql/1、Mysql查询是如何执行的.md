##  一条SQL查询语句是如何执行的

### 连接器

```mysql
mysql -h {ip} -P{端口} -u{用户名} -p{密码}
```

一般情况下不建议将密码在-p后面输入，防止密码泄露。

连接命令中的mysql是客户端工具，以用来跟服务端简历连接。在完成经典的TCP协议握手后，连接器就要开始认证你的身份，这个时候用的就是你输入的用户和密码

- 如果用户名和密码不对，你就会收到一个"Access denied for user"的错误，然后与用户端程序结束执行
- 如果用户名密码认证通过，连接器会到权限表里查询出你拥有的权限，在之后的执行过程进行权限判断

注意：**如果你的用户权限在已经建立连接，那么这个时候修改权限，已连接的用户不会收到影响，需要重新建立连接才会使用新的权限设置**

连接完成后，如果你没有后续动作，连接会处于空闲状态，可以通过show processlist命令中查看所有连接，其中command列显示为"sleep"则表示该连接处于空闲连接

如果客户端太长时间没有动静，连接器会自动将它断开。这个时间是有参数wait_timeout控制的，默认时间为8小时

数据库里面连又分长链接与短连接，建立连接的过程比较复杂，所以建议在使用过程中尽量使用长链接

全部使用长链接后，会发现MySQL在使用过程中占用内存涨的特别快，这是因为MySQL在执行过程中临时使用的内存是在管理连接对象里面。这些资源会在断开的时候释放。所以如果长链接累计下来，可能导致内存占用太大，被系统强行杀掉，从现象上看就是**MySQL异常重启**



### 查询缓存

连接建立完成后，你就可以执行select语句了。执行逻辑就会来到第二部：查询缓存

MySQL拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果会以key-value对的形式，被直接缓存在内存中。ket是查询的语句，value是查询的结果。如果你的查询能直接在这个缓存中找到key，那么这个value会被直接返回给客户端

如果没有击中缓存，则继续后面的执行阶段，后续执行阶段存入缓存

**但是大多数情况下不建议使用查询缓存，因为查询缓存往往弊大于利**

查询缓存的失效非常频繁，只要有一个对表的更新，这个表上面所有的查询缓存会被清空。因此很可能你费劲的把结果存起来，还没使用，就被一个更新给清空了

好在MySQL也提供了这种"按需使用"的方式。你可以将参数query_cache_type设置成DEMAND，这样对默认的SQL语句不使用查询缓存。而对于你确定要使用查询缓存的语句，可以用SQL_CACHE显式指定，像下面这个语句一样：

```mysql
select SQL_CACHE * from T where ID=10
```

要注意的是，MySQL8.0版本直接将查询缓存的整个功能删掉了，也就是说8.0开始彻底没有查询缓存功能了

### 分析器

如果没有命中缓存，就开始真正执行语句了。首先MySQL需要知道你要做什么

分析器会先做"词法分析"。你输入的是由多个字符串和空格组成的一条SQL语句，MySQL需要识别出里面的字符串分别是什么，代表什么

如果语句不对，就会收到"You have an error in your SQL syntax"的错误提醒

```mysql
mysql> elect * from t where ID=1;

ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'elect * from t where ID=1' at line 1
```

### 优化器

经过了分析器，MySQL就知道你要做什么了。在开始执行前，还要先经过优化器处理。

优化器在表里面有个索引的时候，决定使用哪个索引；或者在一个语句有多表关联的时候，决定各个表的连接顺序。比如你执行下面这样的语句，这个语句是执行两个表的join：

```mysql
select * from t1 join t2 using(ID) where t1.c=10 and t2.d =20
```

- 既可以先从表 t1 里面取出 c=10 的记录的 ID 值，再根据 ID 值关联到表 t2，再判断 t2 里面 d 的值是否等于 20。

- 也可以先从表 t2 里面取出 d=20 的记录的 ID 值，再根据 ID 值关联到 t1，再判断 t1 里面 c 的值是否等于 10。

这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。



优化器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。如果你还有一些疑问，比如优化器是怎么选择索引的，有没有可能选择错等等，没关系，我会在后面的文章中单独展开说明优化器的内容。

### 执行器

MySQL通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶段，开始执行语句

开始执行的时候，要先判断一下你对这个表T有没有执行查询的权限，如果没有，就返回没有权限的错误，如果下所示

```mysql
select * from T where ID=10

ERROR 1142 (42000): SELECT command denied to user 'b'@'localhost' for table 'T'
```

如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。

比如我们这个例子中的表T中，ID字段没有索引，那么执行器的执行过程是这样的：

1. 调用InnoDB引擎接口取这个表的第一行，判断ID值是不是10，如果不是则跳过，如果是则将这行存在结果集中；
2. 调用引擎接口取"下一行"，重复相同的逻辑判断，直到取到这个表的最后一行；
3. 执行器将上诉遍历过程中满足条件组成的结果集返回给客户端

至此，这个语句就执行完成了。

对于有索引的表，执行的逻辑也差不多。第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口，这些接口都是引擎中已经定义好的。

你会在数据库的慢查询日志中看到一个 rows_examined 的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。

在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此**引擎扫描行数跟 rows_examined 并不是完全相同的。**我们后面会专门有一篇文章来讲存储引擎的内部机制，里面会有详细的说明。

